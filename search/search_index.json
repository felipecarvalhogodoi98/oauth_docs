{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OAuth 2.0","text":"<p>Este \u00e9 um relat\u00f3rio desenvolvido como parte da disciplina de Programa\u00e7\u00e3o Web, note que est\u00e1 documenta\u00e7\u00e3o pode estar desatualizada no momento em que se esta lendo, consulte a documenta\u00e7\u00e3o oficial.</p> <p>OAuth 2.0 \u00e9 o protocolo padr\u00e3o da industria para autoriza\u00e7\u00e3o. OAuth 2.0 se concentra na simplicidade do desenvolvedor do cliente, ao mesmo tempo em que fornece fluxos de autoriza\u00e7\u00e3o espec\u00edficos para aplicativos da Web, aplicativos de desktop, telefones celulares e dispositivos de sala de estar. Esta especifica\u00e7\u00e3o e suas extens\u00f5es est\u00e3o sendo desenvolvidas no Grupo de Trabalho OAuth da IETF.</p> <p>OAuth 2.1 \u00e9 um esfor\u00e7o em andamento para consolidar o OAuth 2.0 e muitas extens\u00f5es comuns sob um novo nome.</p>"},{"location":"bearer_token/","title":"Bearer token","text":"<p>Bearer Tokens s\u00e3o o tipo predominante de token de acesso usado com OAuth 2.0.</p> <p>Um Bearer Token \u00e9 uma string opaca, sem a inten\u00e7\u00e3o de ter qualquer significado para os clientes que o utilizam. Alguns servidores emitir\u00e3o tokens que s\u00e3o uma sequ\u00eancia curta de caracteres hexadecimais, enquanto outros podem usar tokens estruturados, como JSON Web Tokens.</p>"},{"location":"exemplo/","title":"Implementa\u00e7\u00e3o Pr\u00e1tica","text":""},{"location":"exemplo/#requisitos","title":"Requisitos","text":"<ul> <li>Um servidor OAuth 2.0 configurado</li> <li>Um cliente OAuth 2.0 registrado</li> </ul>"},{"location":"exemplo/#passo-a-passo","title":"Passo a Passo","text":"<ul> <li>Registro do Cliente: Registre sua aplica\u00e7\u00e3o no servidor OAuth 2.0 para obter o client_id e client_secret.</li> <li>Configura\u00e7\u00e3o do Redirecionamento: Configure as URIs de redirecionamento na sua aplica\u00e7\u00e3o e no servidor OAuth 2.0.</li> <li>Implementa\u00e7\u00e3o dos Fluxos de Autoriza\u00e7\u00e3o: Utilize uma biblioteca OAuth 2.0 adequada para a sua linguagem de programa\u00e7\u00e3o para implementar o fluxo escolhido.</li> <li>Manuseio de Tokens: Armazene e utilize os tokens de acesso de maneira segura.</li> <li>Implementa\u00e7\u00e3o de Requisi\u00e7\u00f5es Seguras: Envie o token de acesso nas requisi\u00e7\u00f5es HTTP para acessar recursos protegidos.</li> </ul> <pre><code># Exemplo b\u00e1sico em Python usando Requests para Authorization Code Grant\n\nimport requests\n\n# Solicita\u00e7\u00e3o do c\u00f3digo de autoriza\u00e7\u00e3o\nauthorization_url = (\n    \"https://servidor-autorizacao.com/authorize\"\n    \"?response_type=code\"\n    \"&amp;client_id=seu_cliente_id\"\n    \"&amp;redirect_uri=https://seuapp.com/callback\"\n    \"&amp;scope=read write\"\n    \"&amp;state=xyz\"\n)\nprint(\"Visite o seguinte URL para autorizar:\")\nprint(authorization_url)\n\n# Ap\u00f3s o redirecionamento, pegue o c\u00f3digo de autoriza\u00e7\u00e3o da URL\nauthorization_code = input(\"Digite o c\u00f3digo de autoriza\u00e7\u00e3o: \")\n\n# Troca do c\u00f3digo pelo token de acesso\ntoken_url = \"https://servidor-autorizacao.com/token\"\ndata = {\n    \"grant_type\": \"authorization_code\",\n    \"code\": authorization_code,\n    \"redirect_uri\": \"https://seuapp.com/callback\",\n    \"client_id\": \"seu_cliente_id\",\n    \"client_secret\": \"seu_cliente_secreto\",\n}\nresponse = requests.post(token_url, data=data)\ntoken_response = response.json()\nprint(\"Token de Acesso:\", token_response[\"access_token\"])\n</code></pre>"},{"location":"introducao/","title":"Introduction to OAuth 2.0","text":"<p>OAuth 2.0, ou Open Authorization, \u00e9 um protocolo aberto que fornece um m\u00e9todo seguro e padronizado para que aplicativos de terceiros acessem recursos em nome de um usu\u00e1rio, sem a necessidade de compartilhar as credenciais do usu\u00e1rio. Este protocolo foi projetado para atender \u00e0 demanda crescente por maior seguran\u00e7a e efici\u00eancia no acesso a APIs e servi\u00e7os da web, oferecendo uma forma controlada e limitada de delegar acessos.</p> <p>Desenvolvido como uma evolu\u00e7\u00e3o do OAuth 1.0, o OAuth 2.0 trouxe diversas melhorias significativas, incluindo uma arquitetura simplificada e maior flexibilidade na implementa\u00e7\u00e3o. Ele suporta uma ampla variedade de dispositivos e plataformas, permitindo que desenvolvedores integrem seus aplicativos com servi\u00e7os populares como Google, Facebook, Twitter e muitos outros, sem comprometer a seguran\u00e7a dos dados do usu\u00e1rio.</p> <p>Uma das principais caracter\u00edsticas do OAuth 2.0 \u00e9 a separa\u00e7\u00e3o entre o processo de autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o. Ao contr\u00e1rio do OAuth 1.0, que exigia assinaturas criptogr\u00e1ficas complexas, o OAuth 2.0 utiliza tokens de acesso, que s\u00e3o strings opacas, para conceder permiss\u00f5es aos clientes. Isso simplifica a implementa\u00e7\u00e3o e amplia as possibilidades de uso, tornando o OAuth 2.0 o padr\u00e3o de fato para autoriza\u00e7\u00e3o em ambientes web e mobile.</p> <p>Al\u00e9m disso, OAuth 2.0 \u00e9 altamente extens\u00edvel e pode ser personalizado para atender \u00e0s necessidades espec\u00edficas de diferentes aplicativos e servi\u00e7os. Ele introduz o conceito de \"flows\" ou \"grant types\" que permitem diferentes m\u00e9todos de obten\u00e7\u00e3o de tokens, dependendo do tipo de cliente e do cen\u00e1rio de uso. Esses fluxos incluem o Authorization Code, Implicit, Client Credentials, e Resource Owner Password Credentials, cada um com seus pr\u00f3prios casos de uso e requisitos de seguran\u00e7a.</p> <p>Este relat\u00f3rio t\u00e9cnico explora em detalhes os componentes principais do OAuth 2.0, seus fluxos de autoriza\u00e7\u00e3o, considera\u00e7\u00f5es de seguran\u00e7a, e melhores pr\u00e1ticas para garantir uma implementa\u00e7\u00e3o robusta e segura. A documenta\u00e7\u00e3o \u00e9 projetada para ser uma refer\u00eancia abrangente para desenvolvedores e arquitetos de software que desejam adotar o OAuth 2.0 em suas aplica\u00e7\u00f5es, proporcionando uma compreens\u00e3o clara dos benef\u00edcios e desafios associados ao uso desse protocolo.</p>"},{"location":"jwt/","title":"JSON Web Token","text":"<p>JSON Web Token (JWT, RFC 7519) \u00e9 uma forma de codificar declara\u00e7\u00f5es em um documento JSON que \u00e9 ent\u00e3o assinado.</p> <p>JWTs podem ser usados \u200b\u200bcomo OAuth Bearer Tokens para codificar todas as partes relevantes de um token de acesso no pr\u00f3prio token de acesso, em vez de armazen\u00e1-los em um banco de dados.</p> <p>O JWT \u00e9 uma das solu\u00e7\u00f5es mais implementadas para autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o de Api's. O que voc\u00ea deve saber do JWT:</p> <ul> <li>Oferecem uma maneira estruturada e stateless de guardar informa\u00e7\u00f5es de autoriza\u00e7\u00e3o de um usu\u00e1rio.</li> <li>Permite que a aplica\u00e7\u00e3o client guarde as permiss\u00f5es do usu\u00e1rio.</li> <li>Podem ser encriptados e cryptographically signed para evitar adultera\u00e7\u00f5es.</li> <li>Podem escalar horizontalmente.</li> <li>Possibilita criar servi\u00e7os verdadeiramente RESTful.</li> <li>Expira\u00e7\u00e3o interna.</li> <li>S\u00e3o independentes.</li> </ul> <p>Um JWT possui o seguinte aspecto:</p> <p>eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkJydW5vIiwiaWF0IjoxNTE2MjM5MDIyfQ..YDN0wJHLzyzmqdwycv4wgh-RMBwQR4C_0uehWmo_77ZrAB46YnPYmzJJ2Lb36GyyDXDwRP9Bt759hcVmUiGWEg.</p> <p>H\u00e1 tr\u00eas se\u00e7\u00f5es nesta string, separado por ponto. Header, Payload e Signature.</p>"},{"location":"jwt/#header","title":"Header","text":"<p>O Header \u00e9 um JSON que possui informa\u00e7\u00f5es sobre o tipo de token e o algoritmo de criptografia utilizado.</p>"},{"location":"jwt/#payload","title":"Payload","text":"<p>Tamb\u00e9m \u00e9 um objeto JSON, mas que cont\u00e9m as Claims do usu\u00e1rio. Elas s\u00e3o classificadas em tr\u00eas tipos Reserved, Public e Private</p> <ul> <li>Reserved claims<ul> <li>Atributos reservados pela JWT, recomendados, que s\u00e3o utilizados na valida\u00e7\u00e3o do Token. As mais comuns s\u00e3o iss (issuer), exp (expiration time), sub (subject), aud (audience). Para consultar todos, acesse rfc7519 - Section 4.1</li> </ul> </li> <li> <p>Public claims</p> <p>-Informa\u00e7\u00f5es que ser\u00e3o utilizados na aplica\u00e7\u00e3o para autorizar os recursos que o usu\u00e1rio tem acesso.</p> </li> <li> <p>Private claims</p> <ul> <li>Usadas para compartilhar informa\u00e7\u00f5es entre aplica\u00e7\u00f5es.</li> </ul> </li> </ul>"},{"location":"jwt/#signature","title":"Signature","text":"<p>Para criar a assinatura precisa codificar o Header e o Payload em base64, uma senha e utilizar o algoritmo de criptografia especificado no Header, ap\u00f3s isso dever\u00e1 assinar com a chave de criptografia.</p> <p>Dessa forma previne ataques do tipo man-in-the-middle, garantindo que as informa\u00e7\u00f5es dentro do token s\u00e3o confi\u00e1veis.</p> <p>Veja mais sobre JSON Web Token</p>"},{"location":"oauth2.1/","title":"OAuth 2.1","text":"<p>OAuth 2.1 \u00e9 um esfor\u00e7o em andamento para consolidar e simplificar os recursos mais usados \u200b\u200bdo OAuth 2.0.</p> <p>Desde a publica\u00e7\u00e3o original do OAuth 2.0 (RFC 6749) em 2012, v\u00e1rios novos RFCs foram publicados que adicionam ou removem funcionalidades da especifica\u00e7\u00e3o principal, incluindo OAuth 2.0 para aplicativos nativos (RFC 8252), Proof Key for Code Exchange (RFC 7636) ), OAuth para aplicativos baseados em navegador e melhores pr\u00e1ticas atuais de seguran\u00e7a do OAuth 2.0.</p> <p>OAuth 2.1 consolida as altera\u00e7\u00f5es publicadas em especifica\u00e7\u00f5es posteriores para simplificar o documento principal.</p> <p>As principais diferen\u00e7as do OAuth 2.0 est\u00e3o listadas abaixo.</p> <ul> <li>O PKCE \u00e9 necess\u00e1rio para todos os clientes OAuth que usam o fluxo de c\u00f3digo de autoriza\u00e7\u00e3o</li> <li>Os URIs de redirecionamento devem ser comparados usando a correspond\u00eancia exata de strings</li> <li>A concess\u00e3o impl\u00edcita (response_type=token) \u00e9 omitida nesta especifica\u00e7\u00e3o</li> <li>A concess\u00e3o de credenciais de senha do propriet\u00e1rio do recurso \u00e9 omitida nesta especifica\u00e7\u00e3o</li> <li>O uso do token de portador omite o uso de tokens de portador na string de consulta de URIs</li> <li>Os tokens de atualiza\u00e7\u00e3o para clientes p\u00fablicos devem ser restritos ao remetente ou de uso \u00fanico</li> <li>As defini\u00e7\u00f5es de clientes p\u00fablicos e confidenciais foram simplificadas para se referir apenas se o cliente possui credenciais</li> </ul>"},{"location":"arquitetura/arquitetura/","title":"OAuth 2.0 Architecture Overview","text":"<p>A arquitetura do OAuth 2.0 \u00e9 baseada em um conjunto de componentes principais que interagem para permitir o acesso seguro a recursos protegidos. Esses componentes trabalham juntos para garantir que aplicativos possam acessar dados em nome de um usu\u00e1rio sem expor suas credenciais.</p> <p>Principais Componentes:</p> <ul> <li>Resource Owner: O usu\u00e1rio que possui o recurso.</li> <li>Client: A aplica\u00e7\u00e3o que deseja acessar o recurso.</li> <li>Authorization Server: O servidor que autentica o usu\u00e1rio e emite tokens.</li> <li>Resource Server: O servidor que hospeda o recurso protegido e valida os tokens emitidos.</li> </ul> <p></p>"},{"location":"arquitetura/arquitetura/#fluxo-de-interacoes-na-arquitetura-oauth-20","title":"Fluxo de Intera\u00e7\u00f5es na Arquitetura OAuth 2.0","text":"<p>O fluxo b\u00e1sico de intera\u00e7\u00f5es na arquitetura OAuth 2.0 segue os seguintes passos:</p> <ol> <li> <p>Solicita\u00e7\u00e3o de Autoriza\u00e7\u00e3o: O Client redireciona o Resource Owner para o Authorization Server, solicitando permiss\u00e3o para acessar os recursos protegidos.</p> </li> <li> <p>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o: O Resource Owner autentica-se no Authorization Server e concede ou nega a autoriza\u00e7\u00e3o ao Client.</p> </li> <li> <p>Emiss\u00e3o de Token: Se autorizado, o Authorization Server emite um Access Token (e opcionalmente um Refresh Token) e o fornece ao Client.</p> </li> <li> <p>Acesso ao Recurso: O Client usa o Access Token para fazer uma solicita\u00e7\u00e3o ao Resource Server. O Resource Server valida o token e, se v\u00e1lido, concede acesso ao recurso solicitado.</p> </li> <li> <p>Atualiza\u00e7\u00e3o de Token (opcional): Se o Access Token expirar, o Client pode usar o Refresh Token para solicitar um novo Access Token ao Authorization Server.</p> </li> </ol>"},{"location":"arquitetura/funcoes_e_termos/","title":"Defini\u00e7\u00e3o de termos e fun\u00e7\u00f5es no OAuth 2.0","text":"<p>O protocolo OAuth 2.0 envolve v\u00e1rios atores e termos espec\u00edficos que desempenham pap\u00e9is cr\u00edticos na sua opera\u00e7\u00e3o. Compreender esses pap\u00e9is e a terminologia associada \u00e9 fundamental para implementar o OAuth 2.0 de forma eficaz e segura. Abaixo est\u00e3o as descri\u00e7\u00f5es detalhadas dos principais termos e pap\u00e9is envolvidos no processo:</p> <p>1. Resource Owner (Propriet\u00e1rio do Recurso) O Resource Owner \u00e9 a entidade que possui e controla o acesso aos recursos protegidos. Em contextos comuns, o Resource Owner \u00e9 o usu\u00e1rio final, que possui dados pessoais ou outras informa\u00e7\u00f5es que podem ser acessadas por meio de APIs. Esse usu\u00e1rio pode conceder ou revogar permiss\u00f5es para que um Client acesse seus recursos. No fluxo t\u00edpico, o Resource Owner interage com o Authorization Server para autorizar o Client a obter um Access Token.</p> <p>Exemplo: Um usu\u00e1rio de uma rede social que concede a um aplicativo de terceiros acesso \u00e0 sua lista de amigos.</p> <p>2. Client (Cliente) O Client \u00e9 a aplica\u00e7\u00e3o que deseja acessar recursos protegidos em nome do Resource Owner. Para fazer isso, o Client deve primeiro obter autoriza\u00e7\u00e3o do Resource Owner, normalmente por meio do Authorization Server. Dependendo da natureza da aplica\u00e7\u00e3o, o Client pode ser:</p> <ul> <li>Confidencial: Uma aplica\u00e7\u00e3o que pode proteger suas credenciais, como um backend seguro.</li> <li>P\u00fablica: Uma aplica\u00e7\u00e3o que n\u00e3o pode proteger suas credenciais, como uma aplica\u00e7\u00e3o m\u00f3vel ou um Single Page Application (SPA).</li> </ul> <p>Exemplo: Um aplicativo de terceiros que deseja postar atualiza\u00e7\u00f5es em uma conta de rede social em nome do usu\u00e1rio.</p> <p>3. Authorization Server (Servidor de Autoriza\u00e7\u00e3o) O Authorization Server \u00e9 o componente respons\u00e1vel por autenticar o Resource Owner e emitir os tokens necess\u00e1rios para o Client. Este servidor gerencia a autoriza\u00e7\u00e3o e \u00e9 respons\u00e1vel por garantir que apenas os Clients autenticados e autorizados possam acessar os recursos protegidos.</p> <ul> <li>Emiss\u00e3o de Access Tokens: O Authorization Server emite um Access Token ao Client, que permite o acesso aos recursos protegidos.</li> <li>Emiss\u00e3o de Refresh Tokens: O Authorization Server pode tamb\u00e9m emitir um Refresh Token, que permite ao Client obter novos Access Tokens quando necess\u00e1rio, sem exigir uma nova autoriza\u00e7\u00e3o do Resource Owner.</li> </ul> <p>Exemplo: Um servidor de autentica\u00e7\u00e3o como o OAuth 2.0 do Google, que permite que usu\u00e1rios fa\u00e7am login em diferentes aplicativos usando suas credenciais do Google.</p> <p>4. Resource Server (Servidor de Recursos) O Resource Server hospeda os recursos protegidos que o Client deseja acessar. Ele \u00e9 respons\u00e1vel por validar o Access Token recebido do Client e garantir que este token seja v\u00e1lido e emitido por um Authorization Server confi\u00e1vel. Se o token for v\u00e1lido, o Resource Server permite que o Client acesse os recursos solicitados.</p> <p>Exemplo: O servidor de API de uma rede social que fornece dados de perfil de usu\u00e1rio para aplicativos autorizados.</p> <p>5. Access Token (Token de Acesso) O Access Token \u00e9 uma credencial que o Client usa para acessar recursos protegidos no Resource Server. Este token \u00e9 emitido pelo Authorization Server ap\u00f3s o Resource Owner conceder a autoriza\u00e7\u00e3o. O Access Token cont\u00e9m informa\u00e7\u00f5es que permitem ao Resource Server validar a identidade do Client e as permiss\u00f5es concedidas.</p> <ul> <li>Formato: Pode ser uma string opaca ou um JWT (JSON Web Token), dependendo da implementa\u00e7\u00e3o.</li> <li>Validade: Os Access Tokens t\u00eam uma dura\u00e7\u00e3o limitada, ap\u00f3s a qual se tornam inv\u00e1lidos e devem ser renovados.</li> </ul> <p>Exemplo: Um token JWT contendo as permiss\u00f5es concedidas a um aplicativo para acessar a lista de contatos de um usu\u00e1rio.</p> <p>6. Refresh Token (Token de Atualiza\u00e7\u00e3o) O Refresh Token \u00e9 uma credencial que o Client pode usar para obter novos Access Tokens sem precisar que o Resource Owner realize uma nova autentica\u00e7\u00e3o. Isso \u00e9 \u00fatil para manter sess\u00f5es longas sem exigir que o usu\u00e1rio autentique repetidamente.</p> <ul> <li>Seguran\u00e7a: Refresh Tokens devem ser protegidos rigorosamente, pois podem ser usados para prolongar o acesso aos recursos protegidos.</li> <li>Revoga\u00e7\u00e3o: O Authorization Server pode revogar Refresh Tokens para encerrar a sess\u00e3o de um Client.</li> </ul> <p>Exemplo: Um Refresh Token que permite a um aplicativo de e-mail sincronizar mensagens em segundo plano sem exigir que o usu\u00e1rio fa\u00e7a login repetidamente.</p> <p>7. Authorization Grant (Concess\u00e3o de Autoriza\u00e7\u00e3o) A Authorization Grant \u00e9 um conjunto de credenciais que o Client usa para obter um Access Token do Authorization Server. Existem diferentes tipos de grants, dependendo do fluxo OAuth 2.0 em uso:</p> <ul> <li>Authorization Code: Usado principalmente por aplica\u00e7\u00f5es confidenciais, onde o c\u00f3digo de autoriza\u00e7\u00e3o \u00e9 trocado por um Access Token.</li> <li>Implicit: Utilizado por aplica\u00e7\u00f5es p\u00fablicas, onde o Access Token \u00e9 retornado diretamente.</li> <li>Resource Owner Password Credentials: Usado quando o Client obt\u00e9m as credenciais do Resource Owner diretamente, geralmente em cen\u00e1rios de confian\u00e7a elevada.</li> <li>Client Credentials: Usado quando o Client atua em seu pr\u00f3prio nome, em vez de em nome de um Resource Owner.</li> </ul> <p>Exemplo: O Authorization Code \u00e9 obtido quando um usu\u00e1rio consente em permitir que um aplicativo acesse seus dados durante o fluxo de autoriza\u00e7\u00e3o.</p> <p>8. Scope (Escopo) O Scope define o n\u00edvel de acesso ou os recursos espec\u00edficos que o Client est\u00e1 solicitando. Durante o processo de autoriza\u00e7\u00e3o, o Client especifica quais Scopes ele precisa, e o Resource Owner pode consentir ou restringir esse acesso. O Authorization Server ent\u00e3o emite um Access Token que \u00e9 limitado aos Scopes concedidos.</p> <p>Exemplo: Um Client pode solicitar acesso de leitura ao perfil de usu\u00e1rio e \u00e0 lista de amigos, mas o Resource Owner pode optar por conceder apenas acesso de leitura ao perfil.</p> <p>9. State (Estado) O par\u00e2metro State \u00e9 utilizado para proteger o processo de autoriza\u00e7\u00e3o contra ataques de falsifica\u00e7\u00e3o de solicita\u00e7\u00e3o entre sites (CSRF). Quando o Client inicia uma solicita\u00e7\u00e3o de autoriza\u00e7\u00e3o, ele pode incluir um par\u00e2metro state, que \u00e9 devolvido inalterado pelo Authorization Server ap\u00f3s a conclus\u00e3o do processo de autoriza\u00e7\u00e3o. Isso permite ao Client verificar se a resposta corresponde \u00e0 solicita\u00e7\u00e3o original.</p> <p>Exemplo: O Client gera um valor \u00fanico para o par\u00e2metro state ao iniciar o fluxo de autoriza\u00e7\u00e3o, que \u00e9 ent\u00e3o verificado ap\u00f3s a resposta do Authorization Server.</p> <p>10. Redirect URI (URI de Redirecionamento) A Redirect URI \u00e9 a URL para a qual o Authorization Server redireciona o Resource Owner ap\u00f3s a autoriza\u00e7\u00e3o, enviando o Authorization Code ou o Access Token. Para prevenir ataques, o Authorization Server deve verificar se a Redirect URI registrada corresponde \u00e0quela fornecida na solicita\u00e7\u00e3o.</p> <p>Exemplo: Uma URL no dom\u00ednio do aplicativo Client para onde o Authorization Server redireciona o usu\u00e1rio ap\u00f3s a autoriza\u00e7\u00e3o.</p>"},{"location":"fluxos/cliente_credenciais/","title":"Credenciais do cliente","text":"<p>As credenciais do cliente (ou outras formas de autentica\u00e7\u00e3o do cliente) podem ser usadas como uma concess\u00e3o de autoriza\u00e7\u00e3o quando o escopo da autoriza\u00e7\u00e3o \u00e9 limitado aos recursos protegidos sob o controle do cliente, ou aos recursos protegidos previamente organizados com o servidor de autoriza\u00e7\u00e3o. As credenciais do cliente s\u00e3o usadas como uma concess\u00e3o de autoriza\u00e7\u00e3o normalmente quando o cliente est\u00e1 agindo em seu pr\u00f3prio nome (o cliente tamb\u00e9m \u00e9 o propriet\u00e1rio do recurso) ou est\u00e1 solicitando acesso a recursos protegidos com base em uma autoriza\u00e7\u00e3o previamente combinada com o servidor de autoriza\u00e7\u00e3o.</p>"},{"location":"fluxos/codigo_autorizacao/","title":"Fluxo de Autoriza\u00e7\u00e3o via C\u00f3digo","text":"<p>O fluxo de c\u00f3digo de autoriza\u00e7\u00e3o \u00e9 o fluxo mais amplamente utilizado no OAuth 2.0 devido \u00e0 sua seguran\u00e7a e flexibilidade. Este fluxo \u00e9 ideal para aplicativos confidenciais, como servidores back-end, que podem manter em segredo o client secret. Ele envolve uma intera\u00e7\u00e3o em duas etapas, onde o Authorization Code \u00e9 trocado por um Access Token, garantindo que o Access Token nunca seja exposto diretamente ao usu\u00e1rio final ou a um ambiente inseguro, como o navegador.</p>"},{"location":"fluxos/codigo_autorizacao/#visao-geral-do-fluxo","title":"Vis\u00e3o Geral do Fluxo","text":"<p>O Authorization Code Flow segue os seguintes passos principais:</p> <p>Solicita\u00e7\u00e3o de Autoriza\u00e7\u00e3o: O Client redireciona o Resource Owner para o Authorization Server, solicitando permiss\u00f5es para acessar recursos protegidos.</p> <p>Consentimento e C\u00f3digo de Autoriza\u00e7\u00e3o: O Resource Owner autentica-se e, se concordar em conceder as permiss\u00f5es solicitadas, o Authorization Server emite um Authorization Code e redireciona o Resource Owner de volta ao Client.</p> <p>Troca de C\u00f3digo por Token: O Client envia o Authorization Code juntamente com sua client secret ao Authorization Server para obter um Access Token.</p> <p>Acesso ao Recurso: O Client usa o Access Token para acessar os recursos protegidos no Resource Server.</p>"},{"location":"fluxos/implicito/","title":"Fluxo Impl\u00edcito","text":"<p>O fluxo impl\u00edcito foi criado principalmente para aplicativos p\u00fablicos, como Single Page Applications (SPAs) ou aplicativos m\u00f3veis, onde o Client n\u00e3o pode manter em segredo o client secret. Diferentemente do fluxo de autoriza\u00e7\u00e3o via c\u00f3digo, o fluxo impl\u00edcito simplifica o processo de obten\u00e7\u00e3o de um Access Token ao eliminar a etapa intermedi\u00e1ria de troca de um Authorization Code. Nesse fluxo, o Access Token \u00e9 retornado diretamente ao Client ap\u00f3s a autoriza\u00e7\u00e3o do usu\u00e1rio, sem a necessidade de um servidor back-end para processar a troca do c\u00f3digo por um token.</p> <p>No entanto, devido a preocupa\u00e7\u00f5es de seguran\u00e7a, o fluxo impl\u00edcito \u00e9 considerado menos seguro do que outros fluxos, e seu uso \u00e9 desencorajado em novas implementa\u00e7\u00f5es. Em vez disso, o uso do fluxo de autoriza\u00e7\u00e3o via c\u00f3digo com PKCE (Proof Key for Code Exchange) \u00e9 recomendado para situa\u00e7\u00f5es onde o fluxo impl\u00edcito seria tradicionalmente usado.</p>"},{"location":"fluxos/implicito/#visao-geral-do-fluxo","title":"Vis\u00e3o Geral do Fluxo","text":"<p>O fluxo impl\u00edcito segue os seguintes passos principais:</p> <p>Solicita\u00e7\u00e3o de Autoriza\u00e7\u00e3o: O Client redireciona o Resource Owner para o Authorization Server, solicitando um Access Token diretamente.</p> <p>Consentimento e Emiss\u00e3o de Token: O Resource Owner autentica-se e, se autorizar a solicita\u00e7\u00e3o, o Authorization Server emite um Access Token e o envia de volta ao Client na URL de redirecionamento.</p> <p>Acesso ao Recurso: O Client usa o Access Token para acessar os recursos protegidos no Resource Server.</p>"},{"location":"fluxos/senha_proprietario/","title":"Credenciais de senha do propriet\u00e1rio do recurso","text":"<p>As credenciais de senha do propriet\u00e1rio do recurso (ou seja, nome de usu\u00e1rio e senha) podem ser usadas diretamente como uma concess\u00e3o de autoriza\u00e7\u00e3o para obter um token de acesso. As credenciais s\u00f3 devem ser usadas quando houver um alto grau de confian\u00e7a entre o propriet\u00e1rio do recurso e o cliente (por exemplo, o cliente faz parte do sistema operacional do dispositivo ou de um aplicativo altamente privilegiado) e quando outros tipos de concess\u00e3o de autoriza\u00e7\u00e3o n\u00e3o estiverem dispon\u00edveis ( como um c\u00f3digo de autoriza\u00e7\u00e3o).</p> <p>Embora esse tipo de concess\u00e3o exija acesso direto do cliente \u00e0s credenciais do propriet\u00e1rio do recurso, as credenciais do propriet\u00e1rio do recurso s\u00e3o usadas para uma \u00fanica solicita\u00e7\u00e3o e trocadas por um token de acesso. Este tipo de concess\u00e3o pode eliminar a necessidade de o cliente armazenar as credenciais do propriet\u00e1rio do recurso para uso futuro, trocando as credenciais com um token de acesso de longa dura\u00e7\u00e3o ou um token de atualiza\u00e7\u00e3o.</p>"},{"location":"tokens/access_token/","title":"Access token","text":"<p>Um token de acesso OAuth \u00e9 uma string que o cliente OAuth usa para fazer solicita\u00e7\u00f5es ao servidor de recursos.</p> <p>Access tokens n\u00e3o precisam estar em nenhum formato espec\u00edfico e, na pr\u00e1tica, v\u00e1rios servidores OAuth escolheram muitos formatos diferentes para seus tokens de acesso.</p> <p>Access tokens podem ser <code>bearer tokens</code> ou tokens <code>sender-constrained</code>. Sender-constrained tokens exigem que o cliente OAuth prove a posse de uma chave privada de alguma forma para usar o token de acesso, de modo que o token de acesso por si s\u00f3 n\u00e3o seja utiliz\u00e1vel.</p> <p>H\u00e1 uma s\u00e9rie de propriedades de tokens de acesso que s\u00e3o fundamentais para o modelo de seguran\u00e7a do OAuth:</p> <ul> <li>Access tokens n\u00e3o devem ser lidos ou interpretados pelo cliente OAuth. O cliente OAuth n\u00e3o \u00e9 o p\u00fablico-alvo do token.</li> <li>Access tokens n\u00e3o transmitem a identidade do usu\u00e1rio ou qualquer outra informa\u00e7\u00e3o sobre o usu\u00e1rio ao cliente OAuth.</li> <li>Access tokens s\u00f3 devem ser usados \u200b\u200bpara fazer solicita\u00e7\u00f5es ao servidor de recursos. Al\u00e9m disso, os tokens de ID n\u00e3o devem ser usados \u200b\u200bpara fazer solicita\u00e7\u00f5es ao servidor de recursos.</li> </ul>"},{"location":"tokens/escopos/","title":"Escopos","text":"<p>O escopo \u00e9 um mecanismo no OAuth 2.0 para limitar o acesso de um aplicativo \u00e0 conta de um usu\u00e1rio. Uma aplica\u00e7\u00e3o pode solicitar um ou mais escopos, esta informa\u00e7\u00e3o \u00e9 ent\u00e3o apresentada ao usu\u00e1rio na tela de consentimento, e o token de acesso emitido para a aplica\u00e7\u00e3o ser\u00e1 limitado aos escopos concedidos.</p> <p>Quando um cliente solicita autoriza\u00e7\u00e3o para acessar os dados de um usu\u00e1rio, ele deve especificar quais escopos de acesso ele precisa. Esses escopos s\u00e3o definidos no momento da solicita\u00e7\u00e3o de autoriza\u00e7\u00e3o e s\u00e3o enviados ao servidor de autoriza\u00e7\u00e3o.</p> <p>Por exemplo, ao autorizar uma aplica\u00e7\u00e3o de terceiros, um usu\u00e1rio pode ver uma lista de escopos que a aplica\u00e7\u00e3o est\u00e1 solicitando, como \"leitura de e-mails\", \"acesso ao perfil\", ou \"escrita de arquivos\". O usu\u00e1rio pode ent\u00e3o decidir se concede ou nega esses acessos.</p> <p>Exemplos:</p> <p>1 - Perfil do Usu\u00e1rio</p> <ul> <li><code>profile</code>: Acesso ao perfil b\u00e1sico do usu\u00e1rio, como nome, foto, e-mail.</li> <li><code>email</code>: Acesso ao endere\u00e7o de e-mail do usu\u00e1rio.</li> </ul> <p>2 - Recursos de API Espec\u00edficos</p> <ul> <li><code>read</code>: Permite opera\u00e7\u00f5es de leitura em recursos espec\u00edficos.</li> <li><code>write</code>: Permite opera\u00e7\u00f5es de escrita em recursos espec\u00edficos.</li> <li><code>delete</code>: Permite a exclus\u00e3o de recursos.</li> </ul> <p>3 - Escopos de Servi\u00e7os Espec\u00edficos</p> <ul> <li><code>calendar.read</code>: Leitura dos eventos do calend\u00e1rio do usu\u00e1rio.</li> <li><code>drive.readonly</code>: Acesso de leitura aos arquivos do Google Drive.</li> <li><code>photos.upload</code>: Permite o upload de fotos para um servi\u00e7o.</li> </ul> <p>4 - Escopos de Controle Total</p> <ul> <li><code>admin</code>: Acesso completo para administrar todos os recursos e configura\u00e7\u00f5es.</li> <li><code>superuser</code>: Acesso de superusu\u00e1rio, com permiss\u00f5es para realizar qualquer a\u00e7\u00e3o.  </li> </ul>"},{"location":"tokens/refresh_token/","title":"Refresh token","text":"<p>Um Refresh Token OAuth \u00e9 uma string que o cliente OAuth pode usar para obter um novo token de acesso sem a intera\u00e7\u00e3o do usu\u00e1rio.</p> <p>Clientes p\u00fablicos e confidenciais podem usar refresh token. Se um token de atualiza\u00e7\u00e3o emitido para um cliente p\u00fablico for roubado, o invasor poder\u00e1 se passar pelo cliente e usar o token de atualiza\u00e7\u00e3o sem ser detectado. Tamb\u00e9m \u00e9 poss\u00edvel vincular refresh token \u00e0 inst\u00e2ncia p\u00fablica do cliente usando DPoP, o que pode conter esse ataque. Os clientes confidenciais precisam se autenticar no servidor de autoriza\u00e7\u00e3o para usar o token de atualiza\u00e7\u00e3o, portanto, o risco de refresh token roubados \u00e9 menor para esse tipo de cliente.</p> <p>Um Refresh Token n\u00e3o deve permitir que o cliente obtenha acesso al\u00e9m do escopo da concess\u00e3o original. O token de atualiza\u00e7\u00e3o existe para permitir que os servidores de autoriza\u00e7\u00e3o usem tempos de vida curtos para tokens de acesso sem a necessidade de envolver o usu\u00e1rio quando o token expirar.</p>"}]}